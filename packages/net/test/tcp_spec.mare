:import "spec"
:import "io"

:class iso TCPSpecListenerNotify
  :is TCPListenerNotify
  :prop env Env
  :new (@env)

  :fun ref listening(listen TCPListener'ref)
    TCPConnection.new(
      TCPSpecNotify.new(@env)
      "localhost"
      Inspect[listen.local_address.port].clone // TODO: shouldn't need clone
    )
    @env.err.print("[Listener] Listening")

  :fun ref not_listening(listen TCPListener'ref) None
    @env.err.print("[Listener] Not listening:")
    @env.err.print(listen.listen_error.name)

  :fun ref closed(listen TCPListener'ref): None
    @env.err.print("[Listener] Stopped listening")

  :fun ref connected!(listen TCPListener'ref, ticket TCPAcceptTicket)
    TCPSpecEchoer.new(@env, listen, --ticket)

:actor TCPSpecEchoer
  :is IOActor(IOAction)
  :prop env Env
  :prop io TCPConnectionEngine
  :new (@env, listen, ticket)
    @io = TCPConnectionEngine.accept(@, listen, --ticket)
    @env.err.print("[Echoer] Accepted")

  :fun ref _io_react(action IOAction)
    case (
    | action == IOActionRead |
      @io.pending_reads -> (data |
        @env.err.print("[Echoer] Received:")
        @env.err.print(data.as_string)
        @io.write(data)
        @io.close
      )
    | action == IOActionClosed |
      @env.err.print("[Echoer] Closed")
      try @io.listen.as!(TCPListener).dispose
    )
    @

:class iso TCPSpecNotify
  :is TCPConnectionNotify
  :prop env Env
  :new (@env)

  :fun ref accepted(conn TCPConnectionEngine)
    @env.err.print("[Sender] Accepted")

  :fun ref connected(conn TCPConnectionEngine)
    @env.err.print("[Sender] Connected")
    conn.write(b"Hello, World!")
    try conn.expect!(5)
    None

  :fun ref connect_failed(conn TCPConnectionEngine)
    @env.err.print("[Sender] Failed to connect:")
    @env.err.print(conn.connect_error.name)

  :fun ref closed(conn TCPConnectionEngine)
    @env.err.print("[Sender] Closed")

  :fun ref sent(conn TCPConnectionEngine, data Bytes)
    @env.err.print("[Sender] Sent:")
    @env.err.print(data.as_string)
    data

  :fun ref received(conn TCPConnectionEngine, data Bytes)
    @env.err.print("[Sender] Received:")
    @env.err.print(data.as_string)
    case (
    | data == b"Hello" | try conn.expect!(2)
    | data == b", "    | try conn.expect!(5)
    | data == b"World" | try conn.expect!(0)
    | data == b"!"     | conn.close
    )
    True

:class TCPSpec
  :is Spec
  :const describes: "TCP"

  :it "can listen, connect, send, respond, disconnect, and stop listening"
    TCPListener.new(TCPSpecListenerNotify.new(@env))
